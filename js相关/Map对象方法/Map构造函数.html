<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /* new Map()
        参数0-1个,必须是可迭代元素
        Map()必须用new创建,不使用 new 调用它会抛出 TypeError
        */
        const myMap = new Map([
            [1, "one"],
            [2, "two"],
            [3, "three"],
        ]);
        /*
        Map,可以和Object比较
        ----Map定义:
        保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者基本类型）都可以作为一个键或一个值。
        ----Map用法[区分静态与实例属性和方法]:
        1.属性:size
        2.方法:get\set\delete,keys\values\enteries\forEach,clear,has
        ----Map特点:
        一个键只能出现一次
        可以for...of遍历,每次迭代后会返回一个形式为 [key，value] 的数组

        -----看不懂:"规范要求 map 实现“平均访问时间与集合中的元素数量呈次线性关系”。因此，它可以在内部表示为哈希表（使用 O(1) 查找）、搜索树（使用 O(log(N)) 查找）或任何其他数据结构，只要复杂度小于 O(N)。"
        这句话是关于数据结构中 map 的性能要求的。在编程中，map 是一种关联容器类型，它保存了键值对（key-value pair）的集合。这个集合通过键来索引值。
            这里的“平均访问时间与集合中的元素数量呈次线性关系”意味着 map 的查找性能应该优于线性搜索，也就是说，查找一个元素的平均时间不应该随着元素数量的增加而线性增长。举例来说，如果你有一个包含 N 个元素的 map，找到一个特定元素的时间应该少于扫描所有 N 个元素的时间。
            一些常见的 map 实现方式包括哈希表和搜索树：
                - 哈希表：在哈希表中，键通过一个哈希函数映射到一个索引，然后在该索引的位置存储相应的值。如果哈希函数足够好，哈希表的查找时间可以接近常数时间，也就是 O(1)。然而，当哈希冲突发生时（两个不同的键映射到同一个索引），查找时间可能会增加。
                - 搜索树：在搜索树（如二叉搜索树、红黑树、B树等）中，元素按照某种顺序存储，使得可以通过比较来快速找到特定的元素。搜索树的查找时间通常为 O(log(N))，也就是说，每次比较可以排除剩余元素的一半。
            最后一部分说到的“只要复杂度小于 O(N)”意味着只要查找性能优于线性搜索，就可以用来实现 map，这并不只限于哈希表或搜索树，也可以是其他的数据结构。
        原本NaN!==NaN,但是在Map中视作相等
        */

    </script>
</body>

</html>